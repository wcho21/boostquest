<h1>DAY 3</h1>
<h2>부스트 작업 증명</h2>

<p>당신은 산 건너편에 거의 도착했습니다.
아마도 근처에 문제의 거대한 괴수가 살고 있는 것 같습니다.
하지만 당신이 이곳에 온 것은 또 다른 목적도 있습니다.
여기에 어떤 강한 상대도 이길 수 있다는 부스트 엘릭서<span class="emoji">🧪</span>가 존재한다고 합니다.</p>

<p>그런데, 골동품을 파는 수집가가 그것을 팔고 있네요.
가격을 물어보니, 100 부스트 코인<span class="emoji">🪙</span>이라고 합니다.
그런데 현재 지갑에는 99 부스트 코인밖에 없습니다.
당신은 부스트 코인이 가상 화폐라는 사실을 떠올렸고,
마침 부스트 작업 증명을 해내면 1 부스트 코인을 보상으로 받을 수 있다는 것도 알게 되었습니다.</p>

<p>그렇게 하기 위해서는, <em>부스트 해시 알고리즘</em>을 수행해야 합니다.
부스트 해시 알고리즘은 알파벳 소문자와 숫자로 이루어진 문자열에 대해 40비트 해시 값을 구하는 방법입니다.
그 해시는 <em>부스트 해시</em>라고 불립니다.
부스트 해시를 계산하려면, 처음에 해시 값을 <code>0</code>으로 초기화 합니다.
그리고 해싱할 문자열에 대해 한 문자씩, 다음과 같은 단계를 거칩니다.
해시 값에 부스트 상수인 <code>13,005,196,351</code>을 더합니다.
현재 문자의 <em>부스트 코드</em> 숫자 값을 계산하고, 거기에 <code>91</code>을 더한 숫자를 해시 값에 곱합니다.
여기서 만약 결과가 40비트를 초과한다면, 초과한 비트는 버립니다.
그 40비트를 최하위 비트쪽으로 열 번 <a href="https://en.wikipedia.org/wiki/Circular_shift">순환 시프트</a> 합니다.
이 과정을 각 문자에 대해 반복합니다.</p>

<p><em>부스트 코드 테이블</em>은 문자와 숫자 간 변환 관계를 나타내는 표입니다.
어떤 문자의 <em>부스트 코드</em>는 이 표를 통해 숫자로 변환한 결과입니다.
</p>

<pre><code>BOOST Code Table
a: 0   i:  8   q: 16   y: 24   6: 32
b: 1   j:  9   r: 17   z: 25   7: 33
c: 2   k: 10   s: 18   0: 26   8: 34
d: 3   l: 11   t: 19   1: 27   9: 35
e: 4   m: 12   u: 20   2: 28
f: 5   n: 13   v: 21   3: 29
g: 6   o: 14   w: 22   4: 30
h: 7   p: 15   x: 23   5: 31
</code></pre>

<p>그런데, 부스트 해시 알고리즘의 결과는 <em>부스트40 인코딩 알고리즘</em>으로 변환해 표현하는 관습이 있다는 것을 알고 계신가요?
이 알고리즘은, 40비트 값을 5비트씩 8개로 나눈 뒤에, 각 부분마다 부스트 코드 표를 통해 숫자에서 문자로 변환합니다.</p>

<p>예를 들어, 문자열 <code>abc</code>가 주어졌다고 해봅시다.
부스트 해시 알고리즘에 따르면, 처음 해시 값은 <code>0</code>으로 시작합니다.
부스트 코드 테이블에 따르면, 첫 번째 문자인 <code>a</code>의 부스트 코드는 <code>0</code>으로 주어집니다.
현재 해시 값인 <code>0</code>에 부스트 상수인 <code>13,005,196,351</code>을 더한 뒤, 부스트 코드 값에 <code>91</code>을 더한 숫자인 <code>91</code>을 곱하면 다음 숫자를 얻습니다.</p>

<pre><code>1,183,472,867,941</code></pre>

<p>이를 최상위 비트가 왼쪽으로 오도록 표현하면 다음과 같습니다.</p>

<pre><code>1 00010 01110 00110 00111 10101 10110 10011 00101</code></pre>

<p>이 값은 40비트가 넘기 때문에, 40비트만 남기기 위해 최상위 비트를 버립니다.</p>

<pre><code>00010 01110 00110 00111 10101 10110 10011 00101</code></pre>

<p>이제 최하위 비트쪽으로 순환 시프트를 열 번 수행합니다.</p>

<pre><code>10011 00101 00010 01110 00110 00111 10101 10110</code></pre>

<p>이 값은 십진수로 <code>658,285,731,510</code>이 됩니다.</p>

<p>이제 이 과정을 다음 문자인 <code>b</code>에 대해서 반복합니다.
방금의 결과에 부스트 상수인 <code>13,005,196,351</code>을 더하여 <code>671,290,927,861</code>을 얻습니다.
<code>b</code>의 부스트 코드는 <code>1</code>로 주어집니다.
여기에 <code>91</code>을 더한 숫자는 <code>92</code>이고, 이를 방금의 결과에 곱합니다.
최상위 비트들을 버리고 40비트만 가져오게 되면 <code>13,066,654,044</code>를 얻습니다.</p>

<p>마지막 문자인 <code>c</code>에 대해서는 <code>359,923,880,992</code>를 얻습니다.
마지막 결과를 최상위 비트가 왼쪽으로 오도록 표현하면 다음과 같습니다.</p>

<pre><code>01010 01111 00110 10010 00101 00101 00001 00000</code></pre>

<p>부스트40 인코딩 알고리즘은 각 5비트의 숫자 값마다 부스트 코드 테이블을 통해 문자를 얻습니다.</p>

<pre><code>   binary: 01010 01111 00110 10010 00101 00101 00001 00000
  decimal:    10    15     6    18     5     5     1     0
character:     k     p     g     s     f     f     b     a
</code></pre>

<p>따라서, 문자열 <code>abc</code>의 부스트 해시는 <code>kpgsffba</code>가 됩니다.</p>

<p>다음은 다른 문자열에 대한 부스트 해시 알고리즘의 결과입니다.</p>

<pre><code>mc -> hsopxcje
easy -> n0rg4ihc
boostquest -> vyrufjlt
</code></pre>

<p>당신에게 주어진 문자열이 입력 파일로 주어집니다.
먼저, 당신은 알고리즘을 잘 이해했는지 확인해보려고 합니다.
주어진 문자열의 부스트해시는 무엇이 될까요?</p>
